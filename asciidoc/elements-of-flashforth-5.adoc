= Elements of FlashForth 5
Peter Jacobs, Pete Zawasky and Mikael Nordman
2021-12-30
:toc: right
:stylesheet: ./readthedocs.css
:sectnums:
:imagesdir: ../figs
:stem: latexmath
:eqnums:

This document is a remix of material from a number of Forth tutorials and references, 
adapted to the FlashForth 5 environment.
It provides some examples and explanation of using FlashForth on a PIC18 microcontroller
while concentrating on the features of the language rather than the details of the
microcontroller hardware.
Following an introduction to the FlashForth interpreter, 
we look at adding our own word definitions to the dictionary and then explore
the manipulation of data values on the stack.
Flow of program control and more advanced defining words are also explored.
These defining words are convenient for making arrays.
Finally, strings and formatted numeric output are discussed.

:leveloffset: +1

= Introduction

Forth is an interesting mix of low-level access tools and language building tools.
It is effectively a small toolkit with which you construct a specialized dictionary of words
that work together to form your application code.
This tutorial will explore and explain the workings of the FlashForth 5 toolkit
running on a Microchip PIC18 microcontroller
and complements the more hardware-oriented tutorial,
the FlashForth quick reference and the https://flashforth.com[FlashForth website].
Our interest is in using Forth on the microcontroller in an embedded system,
such as a special-purpose signal timing device,
rather than as part of a general-purpose calculation on a personal computer.

There are quite a number of 
good introductory tutorials^<<brodie_1987,1>>,<<noble_2001,4>>^, 
course notes^<<pelc_2011,5>>^, and references^<<conklin_2007,3>>^ 
for programming in Forth on a desktop or laptop computer,
however, FlashForth running on a PIC18 microcontroller is a different environment.
In the following sections, 
we will follow closely J.V. Noble's tutorial^<<noble_2001,4>>^
for using Forth on a personal computer,
reusing many of his examples and explanations verbatim, 
while adapting the overall tutorial to the use of FlashForth on a microcontroller.

= Getting started

Although we will be using FlashForth on a PIC18 microcontroller, we communicate with it
using a serial terminal program running on a personal computer.
FlashForth comes with a couple of terminal programs (in Python and Tcl/Tk)
that have some conveniences when sending files to the microcontroller,
so we will start our interaction with one of those.
Starting the `ff-shell.tcl` program in a normal terminal window
will start up the Tcl/Tk shell program.
Pressing the `Enter` key &#x23CE; a couple of times should get the display 
as shown in Figure 1.
The `ok<#,ram>` prompt indicates that the current base is ten,
for representing numbers in decimal format, 
and that the current context for making variables is static RAM, 
rather than the Flash memory and EEPROM that is also available in the microcontroller.

.Opening screen using `ff-shell.tcl`.
[#opening_screen]
image::ff5-start-screen-ff-shell-tcl.png[width=80%]

In contrast to Forth on a PC, FlashForth is case sensitive,
with most predefined words being spelled with lower case.
Also, being intended for use in an embedded system, there is no command to exit the system.
FlashForth only stops when the power is removed or a reset occurs.

= The interpreter

FlashForth is an interactive programming language consisting of _words_.
Forth words are the equivalent of subroutines or functions in other languages and are
executed by naming them.
Although FlashForth is interactive at its core, the user doesn't need to
interact with an embedded application if its top-level word is set to automatically
execute at power-up.

Here is an example of executing a FlashForth word: +
`hex` &#x23CE;  `ok<$,ram>` +
This executes the word that sets the base for representing numbers to 16, 
a format that you are likely to be familiar with
if you are a student of mechatronics or computing.
Note that both the text that your typed and the FlashForth response is shown
together, on either side of the `Enter` symbol &#x23CE;.
For the moment, let's return to using decimal numbers: +
`decimal` &#x23CE; `  ok<#,ram>`

Now, let's try something a bit more interesting by entering: +
`2 17 + .` &#x23CE; `19 <#,ram>` +
This time FlashForth more clearly shows its interpretive nature.
A small program called the _outer interpreter_ continually loops,
waiting for input from the serial port.
The input is a sequence of text strings (words or numbers) separated from each other
by the standard Forth delimiter, one or more ASCII blank characters.

The text strings are interpreted in only three ways: words (subroutine or function names),
numbers, or _not defined_.
The outer interpreter tries first to look for the incoming word in the _dictionary_
that contains the already defined words.
If it finds the word, it executes the corresponding code.

If no dictionary entry exists, the interpreter tries to read the input as a number.  
If the string satisfies the rules for defining a number, it is converted to a number
in the microcontroller's internal representation, and stored in a special memory location,
called the _top of stack_ (`TOS`).

In the example above, FlashForth interpreted 2 and 17 as numbers,
and pushed them onto the stack.
`+` is a predefined word, as is `.`, so they are looked up and executed.
The `+` (plus) word removed `2` and `17` from the stack, added them together, 
and left the result `19` on the stack. 
The word `.` (dot) removed `19` from the stack and sent it to the standard output device,
the serial port for FlashForth.
Here is a picture of the stack through the process.
The second-top element of the stack is labelled `NOS` for _next on stack_. +
[cols=6,options="header"]
|===
| word executed 
|
| `2`
| `17`
| `+`
| `.`

| stack result
| `TOS`
| `2`
| `17`
| `19`
| &#x23B5;

|
| `NOS`
| &#x23B5;
| `2`
| &#x23B5;
|

|
|
|
| &#x23B5;
|
|
|===

We might also work in hexadecimal: +
`hex 0a 14 * .` &#x23CE; `c8 <$,ram>` +
This number base is probably convenient for most embedded systems work,
where setting and monitoring bit patterns forms a large part of the code.
If you want to explicitly indicate the base of a number, you can prepend a sigil to the
digits of the number.
For example, `$10`, `#16` and `%10000` all represent the decimal value sixteen.

If the incoming text cannot be located in the dictionary nor interpreted as a number,
FlashForth issues an error message. +
`$0A` &#x23CE; `$0A ?` +
`thing` &#x23CE; `thing ?` +
Note that the apparent hexadecimal number `$0A` was not interpreted as such 
because of the case sensitivity of FlashForth. +
`decimal $0a` &#x23CE; `ok<#,ram>10` +
This time, the hexadecimal number was recognized and its value appears on the stack,
which is printed (in base ten) after the `ok` response.
To assist with the handling of numbers with many digits,
FlashForth allows the convenience of embedding periods into the text of the number.
This is most useful for binary numbers, but it works generally. +
`hex` &#x23CE; `ok<$,ram>` +
`%0100.0000.0000.0000` &#x23CE; `ok<$,ram>4000` +
`$4000` &#x23CE; `ok<$,ram>4000 4000` +
`$4.0.0.0` &#x23CE; `ok<$,ram>4000 4000 4000` +
`$4.` &#x23CE; `ok<$,ram>4000 4000 4000 4 0` +
`decimal` &#x23CE; `ok<#,ram>16384 16384 16384 4 0` +
Note that the period after the number resulted in a double value being placed 
on the stack as two (separate) items.

Other error messages that you might see include `SP ?`, for a stack pointer error, 
and `CO ?`, for a context error.
If the word {asterisk} was to be executed without there being at least two numbers sitting 
on the stack, the interpreter would abort, issuing the `SP` error message, 
and then wait for new input. +
`*` &#x23CE; `ok<#,ram> SP?` 

Finally, to show the compilation and use of a new word,
here is the classic _Hello World!_ program. +
`: hey ." Hello, World!" ;` &#x23CE; `ok<#,ram>` +
Forth lets you output text using the word `."` while the words `:` and `;`
begin and end the definition of your own word `hey`.
Note that blank characters are used to delimit each of these words.
Now, type in `hey` and see what happens. +
`hey` &#x23CE; `Hello, World! ok<#,ram>`

= Extending the dictionary

// It seems that ASCIIdoc has a special form of quoting hell.
// The following lines occasionally put a backslash in front of the asterisk
// that represents multiply in the bits of quoted text.
// This is to stop it being interpreted as "start bold".

Forth belongs to the class of Threaded Interpretive Languages.
This means that it can interpret commands typed at the console,
as well as compile new subroutines and programs.
The Forth compiler is part of the language and special words are
used to make new dictionary entries (_i.e._ words).
The most important are `:` (start a new definition) and
`;` (terminate the definition).
Let's try this out by typing: +
`: \*+  *  +  ;` &#x23CE; `ok<#,ram>` +
What happened?
The action of `:` is to create a new dictionary entry named `*+` and 
switch from _interpret_ to _compile_ mode.
In compile mode, the interpreter looks up words and, rather than executing them,
installs pointers to their code.
If the text is a number, instead of pushing it onto the stack, FlashForth builds
the number into the dictionary space allotted for the new word, 
following special code that puts the stored number onto the stack whenever the 
word is executed.
The run-time action of `\*+` is thus to execute sequentially the previously-defined words
`*` and `+`

The word `;` is special.  
It is an _immediate_ word and is always executed, even if the system is in compile mode.
What `;` does is twofold.
First, it installs the code that returns control to the next outer level 
of the interpreter and, second, it switched back from compile mode to interpret mode.

Now, try out your new word: +
`5 6 7 *+ .` &#x23CE; `47 ok<#,ram>` +
This example illustrated two principal activities of working in Forth:
adding a new word to the dictionary, and trying it out as soon as it was defined.

Note that, in FlashForth, names of dictionary entries are limited to 15 characters.
Also, FlashForth will not redefine a word that already exists in the dictionary.
This can be convenient as you build up your library of Forth code because it allows
you to have repeated definitions, say for special function registers, in several files
and not have to worry about the repetition.

== Dictionary management

The word `empty` will remove all dictionary entries that you have made and
reset all memory allocations to the original values of the core FlashForth interpreter.
As you develop an application, it will often be convenient to return to an earlier,
intermediate dictionary and memory allocation state. 
This can be done with the word `marker`.
For example, we could issue the command
----
marker -my-mark
----
Later, after we have done some work with the FlashForth system and 
defined a few of our own words and variables,
we can return the dictionary and memory allocation to the earlier state
by executing the word `-my-mark`.
Here, we have arbitrarily chosen the word `-my-mark` 
so it would be good to choose a word that has
some specific and easily remembered meaning for us.

= Stacks and reverse Polish notation

The stack is the Forth analog of a pile of cards with numbers written on them.
The numbers are always added to the top of the pile, and removed from the top of the pile.
FlashForth incorporates two stacks: the parameter stack and the return stack,
each consisting of a number of cells that can hold 16-bit numbers.

The Forth input line +
`decimal 2 5 73 -16` &#x23CE; +
leaves the parameter stack in the state +
[cols=3,options="header"]
|===
| cell number 
| content 
| comment

| 0 
| `-16` 
| `TOS` (Top Of Stack)

|1 
| `73` 
| `NOS` (Next On Stack)

| 2 
| `5`
|

| 3 
| `2`
|

|
| &#x23B5;
|
|===
We will usually employ zero-based relative numbering in Forth data structures
such as stacks, arrays and tables.
Note that, when a sequence of numbers is entered like this, the right-most number
becomes TOS and the left-most number sits at the bottom of the stack.

Suppose that we followed the original input line with the line +
`+ - * .` &#x23CE; +
to produce a value _xxx_.
What would the _xxx_ be?
The operations would produce the successive stacks: +
[cols=7,options="header"]
|===
| word executed
|
|
| `+`
| `-`
| `*`
| `.`

| stack result
| `TOS`
| `-16`
| `57`
| `-52`
| `-104`
| &#x23B5;

|
| `NOS`
| `73`
| `5`
| `2`
| &#x23B5;
|

|
|
| `5`
| `2`
| &#x23B5;
|
|

|
|
| `2`
| &#x23B5;
|
|
|

|
|
| &#x23B5;
|
|
|
|

|===

So, after both lines, the terminal window shows
----
decimal 2 5 73 -16  ok<#,ram>2 5 73 65520 
+ - * . -104  ok<#,ram>
----
Note that FlashForth conveniently displays the stack elements on interpreting each line 
and that the value of -16 is displayed as the 16-bit unsigned integer 65520.
Also, the word `.` consumes the -104 data value, leaving the stack empty.
If we execute `.` on the now-empty stack, the outer interpreter aborts with
a stack pointer error (`SP ?`).

The programming notation where the operands appear first,
followed by the operator(s) is called reverse Polish notation (RPN).
It will be familiar to students who own RPN calculators made by Hewlett-Packard.


== Manipulating the parameter stack

Being a stack-based system, FlashForth must provide ways to put numbers onto the stack,
to remove them and to rearrange their order.
We've already seen that we can put numbers onto the stack by simply typing the number.
We can also incorporate the number into the definition of a Forth word.

The word `drop` removes a number from the TOS thus making NOS the new TOS.
The word `swap` exchanges the top 2 numbers.
`dup` copies the TOS into NOS, pushing all of the other numbers down.
`rot` rotates the top 3 numbers, bring the number that was just below NOS to the TOS.
These actions are shown below.

[cols=7,options="header"]
|===
| word executed
|
|
| `drop`
| `swap`
| `rot`
| `dup`

| stack result
| TOS
| `-16`
| `73`
| `5`
| `2`
| `2`

|
| NOS
| `73`
| `5`
| `73`
| `5`
| `2`

|
|
| `5`
| `2`
| `2`
| `73`
| `5`

|
|
| `2`
| &#x23B5;
| &#x23B5;
| &#x23B5;
| `73`

|
|
| &#x23B5;
|
|
|
| &#x23B5;

|===

FlashForth also includes the words `over`, `tuck` and `pick` that act as shown below.
`over` makes a copy of NOS and then leaves it as the new TOS.
`tuck` make a copy of the TOS and inserts the copy just below the NOS.
Note that `pick` must be preceeded by an integer that (gets put on the stack briefly and) 
says where on the stack an element gets picked.
Also, for the PIC18 version of FlashForth, 
the definition of `pick` is provided as Forth source code in the file `pick.fs`.
The content of this file must be sent to the microcontroller to define the word before we try to use it. 

[cols=6,options="header"]
|===
| word executed
|
|
| `over`
| `tuck`
| `4 pick`

| stack result
| TOS
| `-16`
| `73`
| `73`
| `5`

|
| NOS
| `73`
| `-16`
| `-16`
| `73`

|
|
| `5`
| `73`
| `73`
| `-16`

|
|
| `2`
| `5`
| `73`
| `73`

|
|
| &#x23B5;
| `2`
| `5`
| `73`

|
|
|
| &#x23B5;
| `2`
| `5`

|
|
|
|
| &#x23B5;
| `2`

|
|
|
|
|
| &#x23B5;

|===

From these actions, we can see that `0 pick` is the same as `dup`,
`1 pick` is a synonym for `over`.
The word `pick` is mainly useful for dealing with deep stacks, however,
you should avoid making the stack deeper than 3 or 4 elements.
If you are finding that you often have to reason about deeper stacks, 
consider how you might refactor your program.

Double length (32-bit) numbers can also be handled in FlashForth.
A double number will sit on the stack as a pair of 16-bit cells, 
with the cell containing the least-significant 16-bits 
sitting below the cell containing the most-significant 16-bits. 
The words for manipulating pairs of cells on the parameter stack are
`2dup`, `2swap`, `2over` and `2drop`.
For example, we can put a double value onto the stack by putting a period
as the last character of the number literal. +
`hex 23.` &#x23CE; `ok<$,ram>23 0` 

Memory on microcontrollers is limited and,
for FlashForth on the PIC18, the parameter stack is limited to 26 cells.
If you accumulate too many items on the stack, 
it will overflow and the interpreter will abort.
The stack will be emptied and the interpreter will wait for further input.


== The return stack and its uses

During compilation of a new word, FlashForth establishes links from the calling word
to the previously-defined words that are to be invoked by execution of the new word.
This linkage mechanism, during execution, uses the return stack (rstack).
The address of the next word to be invoked is placed on the rstack so that,
when the current word is done executing, the system knows where to jump 
to the next word.
Since words can be nested, there needs to be a stack of these return addresses.

In addition to serving as the reservoir of return addresses, 
the return stack is where the counter for the `for ... next` construct is placed.
(See the section on looping.)
The user can also store to and retrieve from the rstack but this must be done carefully
because the rstack is critical to program execution.
If you use the rstack for temporary storage, you must return it to its original state,
or else you will probably crash the FlashForth system.
Despite the danger, there are times when use of the rstack as temporary storage can make
your code less complex.

To store to the rstack, use `>r` to move TOS from the parameter stack 
to the top of the rstack.
To retrieve a value, `r>` moves the top value from the rstack 
to the parameter stack TOS.
To simply remove a value from the top of the rstack there is the word `rdrop`.
The word `r@` copies the top of the rstack to the parameter stack TOS 
and is used to get a copy of the loop counter in a `for` loop 
discussed in the section on looping. 


= Using memory

As well as static RAM, the PIC18 microcontroller has program memory, or Flash memory,
and also EEPROM.
Static RAM is usually quite limited on PIC18 controllers and the data stored there is
lost if the MCU loses power.
The key attribute of RAM is that it has an unlimited endurance for being rewritten.
The Flash program memory is usually quite a bit larger and is retained, 
even with the power off.
It does, however, have a very limited number of erase-write cycles that it can endure.
EEPROM is also available, in even smaller amounts than static RAM and is non-volatile.
It has a much better endurance than Flash, but any particular cell 
is still limited to about 100000 rewrites.
It is a good place to put variables that you change occasionally but 
must retain when the power is off.
Calibration or configuration data may be an example of the type of data 
that could be stored in EEPROM.
The registers that configure, control and monitor the microcontroller's peripheral devices 
appear as particular locations in the static RAM memory.

In FlashForth, 16-bit numbers are fetched from memory to the stack by the word `@` (fetch)
and stored from TOS to memory by the word `!` (store).
`@` expects an address on the stack and replaces the address by its contents.
`!` expects a number (NOS) and an address (TOS) to store it in.
It places the number in the memory location referred to by the address, 
consuming both parameters in the process.

Unsigned numbers that represent 8-bit (byte) values can be placed in character-sized cells
of memory using `c@` and `c!`.
This is convenient for operations with strings of text, but is especially useful
for handling the microcontroller's peripheral devices via their special-function
file registers.
For example, data-latch register for port B digital input-output 
is located at address `$ff8a` 
and the corresponding tristate-control register at address `$ff93`.
We can set pin RB0 as an output pin by setting the corresponding bit in the 
tristate control register to zero. +
`%1111.1110 $ff93 c!` &#x23CE; `ok<$,ram>` +
and then set the pin to a digital-high value by writing a 1 to the port's latch register +
`1 $ff8a c!` &#x23CE; `ok<$,ram>` +
If we had a light-emitting diode attached to this pin, via a current-limiting resistor,
we should now see it light up as in the companion hardware tutorial.
Here is what the terminal window contains after turning the LED on and off a couple of times.
----
warm 
S FlashForth 5 PIC18F26K22 11.11.2016

%1111.1110 $ff93 c!  ok<#,ram>
1 $ff8a c!  ok<#,ram>
0 $ff8a c!  ok<#,ram>
1 $ff8a c!  ok<#,ram>
0 $ff8a c!  ok<#,ram>
----
Note that we started the exercise with a _warm_ restart so that the FlashForth
environment was in a known good state.
Being interactive, FlashForth allows you to play with the hardware very easily.


== Variables

A variable is a named location in memory that can store a number,
such as the intermediate result of a calculation, off the stack.
For example, +
`variable x` &#x23CE; `ok<#,ram>` +
creates a named storage location, `x` which executes by leaving the address
of its storage location as TOS: +
`x` &#x23CE; `ok<#,ram>61806` +
We can then fetch from or store to this address as described in the previous section.
----
empty warm 
S FlashForth 5 PIC18F26K22 11.11.2016

marker -play  ok<#,ram>
variable x  ok<#,ram>
3 x !  ok<#,ram>
x @ . 3  ok<#,ram>
----
For FlashForth, the dictionary entry, `x`, 
is in the Flash memory of the microcontroller but the
storage location for the number is in static RAM (in this instance).
Note that the `empty` word was used to discard all dictionary entries that
we may have made on top of the base system.
If you are unsure of what dictionary entries you have made, 
use `words` to display all current dictionary entries.

FlashForth provides the words `ram`, `flash` and `eeprom`
to change the memory context of the storage location.
Being able to conveniently handle data spaces in different
memory types is a major feature of FlashForth.
To make another variable in EEPROM, try +
`eeprom variable y` &#x23CE; `ok<#,eeprom>` +
We can access this new (nonvolatile) variable as we did for the RAM variable `x`,
but `y` retains its value, even when we turn off and on the power to the microcontroller.
----
4 y !  ok<#,eeprom>
y @ . 4  ok<#,eeprom>
x @ . 3  ok<#,eeprom>

 FlashForth 5 PIC18F26K22 11.11.2016

y @  ok<#,ram>4 
x @  ok<#,ram>4 0 
----
In the example above, we reset the microcontroller by bringing its MCLR pin low for a moment.

== Constants

A constant is a number that you would not want to change during a program's execution.
The addresses of the microcontroller's special-function registers are a good example 
of use and, because the constant numbers are stored in nonvolatile Flash memory, they are
available even after a hardware reset.
The result of executing the word associated with a constant is the data value being left on the stack.
----
$ff93 constant trisb  ok<#,ram> 
$ff8a constant latb  ok<#,ram>
%1111.1110 trisb c!  ok<#,ram>
0 latb c!  ok<#,ram>
1 latb c!  ok<#,ram>
0 latb c!  ok<#,ram>

 FlashForth 5 PIC18F26K22 11.11.2016

hex trisb   ok<$,ram>ff93 
%1111.1110 trisb c!  ok<$,ram>ff93 
0 latb c!  ok<$,ram>ff93 
1 latb c!  ok<$,ram>ff93 
----

== Values

A `value` is a hybrid type of variable and constant.
We define and initialize a value and invoke it as as we would for a constant.
We can also change a value as we can a variable.
----
decimal  ok<#,ram>
13 value thirteen  ok<#,ram>
thirteen  ok<#,ram>13 
47 to thirteen  ok<#,ram>13 
thirteen  ok<#,ram>13 47 
----
The word `to` also works within word definitions, replacing the value that
follows it with whatever is currently in TOS.
You must be careful that `to` is followed by a value and not something else.


== Basic tools for allocating memory

The words `create` and `allot` are the basic tools for setting aside memory
and attaching a convenient label to it.
For example, the following transcript shows a new dictionary entry `x` being created 
and an extra 16 bytes of memory being allotted to it.
----
empty warm 
S FlashForth 5 PIC18F26K22 11.11.2016

hex  ok<$,ram>
create x  ok<$,ram>
x u. f16e  ok<$,ram>
here u. f16e  ok<$,ram>
10 allot  ok<$,ram>
here u. f17e  ok<$,ram>
----
When executed, the word `x` will push the address of the first entry 
in its allotted memory space onto the stack.
The word `u.` prints an unsigned representation of a number and 
the word `here` returns the address of the next available space in memory.
In the example above, it starts with the same value as `x` but is incremented 
by (decimal) sixteen when we allotted the memory.

We can now access the memory allotted to `x` using the fetch and store words 
discussed earlier, in the section on memory.
To compute the address of the third byte allotted to `x` we could say `x 2 +`,
remembering that indices start at 0.
----
30 x 2 + c!  ok<$,ram>
x 2 + c@  ok<$,ram>30 
----
We will discuss a way to neatly package the snippets of code required to do the address
calculation later, in the section on creating arrays.
Finally, note that the memory context for this example has been the static RAM, however, 
(as shown for variables in the section on variables)
the context for allotting the memory can be changed.


= Comparing and branching

= Comments in Forth code

= Integer arithmetic operations

= A little more on compiling

= Looping and structured programming

= More on defining words

== create ... does&gt; ...

== Creating arrays

== Jump tables

= Strings

== Pictured numeric output

= Forth programming style

There is much written on the style of Forth programming and, indeed, there is book
called "Thinking Forth".^<<brodie_2004,2>>^
Here are a number of recurring statements on programming in Forth that are relevant
to sections of this tutorial:

- Build your application from the bottom up, testing new words as you go.
- Choose simple and meaningful names, so that the intent of each word is clear
  and your code is easily read, almost as statements you would make to another person.
- Always provide stack-effect comments.
- As you build your application, refactor your code aggressively so that you
  don't need complicated stack manipulations to access your data.
- Clean up after yourself and don't leave rubbish on the stack.
- Use the return-stack for temporary storage when it makes your code cleaner
  but be very careful to clean up when doing so.


[bibliography]
= References

* [[[brodie_1987,1]]] Brodie, L. and Forth Inc. (1987) Starting Forth: An introduction to the Forth Language and operating system for beginners and professionals, 2nd Ed. _Prentice Hall_  ISBN 0-13-843079-9. Also, updated and online http://home.iae.nl/users/mhx/sf.html and the official online version http://www.forth.com/starting-forth/

* [[[brodie_2004,2]]] Brodie, L. (2004) Thinking Forth: A Language and Philosophy for Solving Problems. _Punchy Publishing_ ISBN 0976458705. Also online http://thinking-forth.sourceforge.net/

* [[[conklin_2007,3]]] Conklin, E. K. and Rather, E. D. (2007) Forth Programmer's Handbook, 3rd Ed. _Forth Inc._ ISBN 1-4196-7549-4

* [[[noble_2001,4]]] Noble, J. V. (2001) A Beginner's Guide to Forth, http://galileo.phys.virginia.edu/classes/551.jvn.fall01/primer.htm

* [[[pelc_2011,5]]] Pelc, S. (2011). Programming Forth. _Microprocessor Engineering Limited_, ISBN 978-0-9525310-5-0.  http://www.mpeforth.com/


